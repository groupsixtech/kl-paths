PROGRAM class_name
%NOBUSYLAMP
%COMMENT = 'path class'
%NOLOCKGROUP

%include namespace.m

%include errors.klt
%include systemlib.klt
%include systemvars.klt
%include paths.klt
%include pathplan.klt
%include draw.klt

%ifdef define_paths_types
define_paths_types(PATH_DATA_TYPE, class_name)
%endif

%define BASE_CLASSNAME class_name

VAR
  frm : XYZWPR
  tool_offset : PATH_DATA_TYPE
  idod_ : INTEGER
  intrp_tool_ : BOOLEAN
  coord_system : t_COORD_SYS
  segment : PATH nodedata = t_TOOLPATH
  pth : PATH nodedata = t_TOOLPATH

%include errors.klh
%include pose.klh
%include paths.klh
%from systemlib.klh %import VEC, VEC2D
%from registers.klh %import set_real, set_int

--path plan
define_pathplan(PATH_PLAN_NAME,PATH_CONFIG_FILENAME)
define_pplan_headers(PATH_PLAN_NAME)

%defeval class_name BASE_CLASSNAME

%include pathclass.klh
%include pathclass.private.klh

-- **** MUST BE DEFINED IN TEMPLATE FILE (.klt)
define_paths_members(class_name)

--private

ROUTINE set_orientation
  VAR
    orient : VECTOR
  BEGIN
    --set point orientation
    SELECT (coord_system.system) OF
      CASE(PTH_CYLINDER):
        IF idod = -1 THEN
          orient = UP_NORMAL
        ELSE
          orient = DOWN_NORMAL
        ENDIF
      CASE(PTH_POLAR):
        IF idod = -1 THEN
          orient = POLAR_UP_NORMAL
        ELSE
          orient = POLAR_DOWN_NORMAL
        ENDIF
      --cartesian
      ELSE:
        IF idod = -1 THEN
          orient = UP_NORMAL
        ELSE
          orient = DOWN_NORMAL
        ENDIF
    ENDSELECT

    RETURN(orient)
  END set_orientation

ROUTINE next_toolpath
%ifdef ROT_GRP
  VAR
    endpnts : ARRAY[2] OF t_TOOLPATH
    status : INTEGER
%endif
  BEGIN
    SELECT `PATH_PLAN_NAME`__next_toolpath OF
      CASE(PTH_TOOLING):
        IF interp_tool THEN
          `PATH_PLAN_NAME`__get_toolpath_interpolate(tool_step, PTH_LINETO, FALSE, pth)
        ENDIF
        registers__set_real(SPEED_REGISTER, tool_speed)
      CASE(PTH_LINKING):
%ifdef ROT_GRP
          --If rotary group (ROT_GRP) and line is < 90 deg
          --only include endpoints in line. If path is 0->360
          --it will not rotate all the way back around
          endpnts = `PATH_PLAN_NAME`__get_endpoints
          IF UNINIT(endpnts[1].v) THEN
            paths__clear_toolpath(pth)
          ELSE
            IF(ABS(endpnts[2].v.x-endpnts[1].v.x) < 270) THEN
              `PATH_PLAN_NAME`__get_toolpath_interpolate(link_step, PTH_LINETO, FALSE, pth)
            ELSE
              paths__clear_toolpath(pth)
              APPEND_NODE(pth,status)
              pth[PATH_LEN(pth)] = endpnts[1]
              APPEND_NODE(pth,status)
              pth[PATH_LEN(pth)] = endpnts[2]
            ENDIF
          ENDIF
%else
          `PATH_PLAN_NAME`__get_toolpath_interpolate(link_step, PTH_LINETO, FALSE, pth)
%endif
        registers__set_real(SPEED_REGISTER, link_speed)
    ENDSELECT

    --raise if linking
    paths__offset_toolpath(pth, POS(0,0,retract_hght,0,0,0,(ZEROPOS(1).config_data)), PTH_NULL, PTH_LINKING)
    
    --convert to cartesian
    SELECT (coord_system.system) OF
      CASE(PTH_CYLINDER):
        paths__cylindrical_to_cartesian(pth, frm, (coord_system.z_axis))
      CASE(PTH_POLAR):
        paths__polar_to_cartesian(pth, frm, (coord_system.z_axis))
      ELSE:
    ENDSELECT
  END next_toolpath

ROUTINE get_toolpath
%ifdef ROT_GRP
  VAR
    endpnts : ARRAY[2] OF t_TOOLPATH
    status : INTEGER
%endif
  BEGIN
    paths__clear_toolpath(pth)
    REPEAT
      SELECT (`PATH_PLAN_NAME`__next_toolpath) OF
        CASE(PTH_TOOLING):
          IF interp_tool THEN
            `PATH_PLAN_NAME`__get_toolpath_interpolate(tool_step, PTH_LINETO, TRUE, pth)
          ENDIF
          registers__set_real(SPEED_REGISTER, tool_speed)
        CASE(PTH_LINKING):
%ifdef ROT_GRP
          --If rotary group (ROT_GRP) and line is < 90 deg
          --only include endpoints in line. If path is 0->360
          --it will not rotate all the way back around
          endpnts = `PATH_PLAN_NAME`__get_endpoints
          IF NOT UNINIT(endpnts[1].v) THEN
            IF(ABS(endpnts[2].v.x-endpnts[1].v.x) < 270) THEN
              `PATH_PLAN_NAME`__get_toolpath_interpolate(link_step, PTH_LINETO, TRUE, pth)
            ELSE
              APPEND_NODE(pth,status)
              pth[PATH_LEN(pth)] = endpnts[1]
              APPEND_NODE(pth,status)
              pth[PATH_LEN(pth)] = endpnts[2]
            ENDIF
          ENDIF
%else
          `PATH_PLAN_NAME`__get_toolpath_interpolate(link_step, PTH_LINETO, TRUE, pth)
%endif
          registers__set_real(SPEED_REGISTER, link_speed)
      ENDSELECT
    UNTIL( `PATH_PLAN_NAME`__is_path_end )

    --lower linking path
    paths__offset_toolpath(pth, POS(0,0,retract_hght,0,0,0,(ZEROPOS(1).config_data)), PTH_NULL, PTH_LINKING)

    --convert to cartesian
    SELECT (coord_system.system) OF
      CASE(PTH_CYLINDER):
        paths__cylindrical_to_cartesian(pth, frm, (coord_system.z_axis))
      CASE(PTH_POLAR):
        paths__polar_to_cartesian(pth, frm, (coord_system.z_axis))
      ELSE:
    ENDSELECT
  END get_toolpath

ROUTINE get_midpoint
  VAR
    nde : t_TOOLPATH
    v, o : VECTOR
  BEGIN
    --load start point meta data
    nde.code = code ; nde.typ = typ;

    v = 0.5*pose__pose_to_vector(pth[end_idx].v) + 0.5*pose__pose_to_vector(pth[start_idx].v)
    o = 0.5*pose__get_orientation(pth[end_idx].v) + 0.5*pose__get_orientation(pth[start_idx].v)
    nde.v = POS(v.x, v.y, v.z, o.x, o.y, o.z, pth[end_idx].v.config_data)

    RETURN(nde)
  END get_midpoint

--public

ROUTINE new
  BEGIN
    paths__clear_toolpath(segment)
    paths__clear_toolpath(pth)

    frm = POS(0,0,0,0,0,0, pose__set_config(DEFAULT_CONFIG))
    tool_offset = DEFAULT_POSE

    set_coordinate_system(PTH_CARTESAN, 3)
  END new

ROUTINE init
  BEGIN
    paths__clear_toolpath(segment)
    paths__clear_toolpath(pth)

    frm = coord_frm
    tool_offset = set_tool_offset(toolOffst)

    coord_system = coord_sys

    --registers preset in template
    set_idod(PAD_IDOD)
  END init

ROUTINE destructor
  VAR
    unit_sys : t_COORD_SYS
  BEGIN
    paths__clear_toolpath(segment)
    paths__clear_toolpath(pth)

    coord_system = unit_sys
    idod_ = 0
    intrp_tool_ = TRUE

    frm = (ZEROPOS(1))
    tool_offset = DEFAULT_POSE

    --free path plan
    `PATH_PLAN_NAME`__destructor
  END destructor

ROUTINE set_idod
  BEGIN
    idod_ = i
  END set_idod

ROUTINE set_interpolation
  BEGIN
    intrp_tool_ = interp
  END set_interpolation

ROUTINE set_coordinate_system
  BEGIN
    coord_system.system = system
    coord_system.z_axis = z_axis
  END set_coordinate_system

ROUTINE get_path
  VAR
    status : INTEGER
  BEGIN
    COPY_PATH(pth, 0, 0, out_path, status)
  END get_path

ROUTINE get_plan
  VAR
    status : INTEGER
  BEGIN
    `PATH_PLAN_NAME`__get_plan(out_path)
  END get_plan

ROUTINE createPath
  BEGIN
    `PATH_PLAN_NAME`__init(lines, origin)
    IF raster_type = NEARESTNEIGHBOR THEN
      `PATH_PLAN_NAME`__NN_graph
    ELSE
      --(poly_depend, strict_dir)
      `PATH_PLAN_NAME`__raster_graph(raster_type, poly_depend, TRUE)
    ENDIF

    IF PATH_LEN(contours) > 0 THEN
      --append contours after to not include in rastering process
      -- (add to kd tree)
      `PATH_PLAN_NAME`__append_path(contours, FALSE)
    ENDIF

    `PATH_PLAN_NAME`__MST(`PATH_PLAN_NAME`__closest_bounding_box(start_corner))

    --set point orientation
    `PATH_PLAN_NAME`__set_orientation( set_orientation(idod_) )

  END createPath

ROUTINE loadPath
  BEGIN
    `PATH_PLAN_NAME`__new(origin)
    `PATH_PLAN_NAME`__importPath(filename)
    
    --set if wanting to interpolate toolpath
    intrp_tool_ = intrep_tool

    IF raster_type = NEARESTNEIGHBOR THEN
      `PATH_PLAN_NAME`__NN_graph
    ELSE
      --(poly_depend, strict_dir)
      `PATH_PLAN_NAME`__raster_graph(raster_type, poly_depend, TRUE)
    ENDIF

    `PATH_PLAN_NAME`__MST(`PATH_PLAN_NAME`__closest_bounding_box(start_corner))

    --set point orientation
    `PATH_PLAN_NAME`__set_orientation( set_orientation(idod_) )

  END loadPath

ROUTINE makeline
  VAR
    status : INTEGER
  BEGIN
    paths__clear_toolpath(segment)
    --add start point
    APPEND_NODE(segment,status)
    segment[PATH_LEN(segment)] = paths__new_tpath(pose__vector_to_pose(start_point, set_orientation(idod_), frm.config_data), PTH_MOVETO, line_typ)
    --add end point
    APPEND_NODE(segment,status)
    segment[PATH_LEN(segment)] = paths__new_tpath(pose__vector_to_pose(end_point, set_orientation(idod_), frm.config_data), PTH_CLOSE, line_typ)

    paths__clear_toolpath(pth)
    paths__interpolate_toolpath(segment, (spacing), line_code, POS(0,0,0,0,0,0,frm.config_data), pth)

    IF UNINIT(coord_system.system) THEN
      karelError(VAR_UNINIT,'coordinate system must be set in class_name', ER_ABORT)
    ENDIF

    SELECT (coord_system.system) OF
      CASE(PTH_CYLINDER):
        paths__cylindrical_to_cartesian(pth, frm, (coord_system.z_axis))
      CASE(PTH_POLAR):
        paths__polar_to_cartesian(pth, frm, (coord_system.z_axis))
      ELSE:
    ENDSELECT

  END makeline

ROUTINE get_line
  BEGIN
    paths__clear_toolpath(segment)
    --get line
    `PATH_PLAN_NAME`__set_line(line_no, revrs_ordr, line_typ)

    IF reverse_line THEN
      `PATH_PLAN_NAME`__reverse_toolpath(segment)
    ELSE
      `PATH_PLAN_NAME`__get_toolpath(segment)
    ENDIF

    IF NOT append THEN
      paths__clear_toolpath(pth)
    ENDIF
    paths__interpolate_toolpath(segment, (spacing), PTH_LINETO, origin, pth)

    IF UNINIT(coord_system.system) THEN
      karelError(VAR_UNINIT,'coordinate system must be set in class_name', ER_ABORT)
    ENDIF

    SELECT (coord_system.system) OF
      CASE(PTH_CYLINDER):
        paths__cylindrical_to_cartesian(pth, frm, (coord_system.z_axis))
      CASE(PTH_POLAR):
        paths__polar_to_cartesian(pth, frm, (coord_system.z_axis))
      ELSE:
    ENDSELECT

  END get_line

ROUTINE moveLine
  VAR
    i : INTEGER
    nde : PATH_DATA_TYPE
  BEGIN
    --set tool orientation
    set_posereg(tool_offset, TOOL_OFFSET_REG)

    FOR i=1 TO PATH_LEN(pth) DO
      --set code and type for tp
      registers__set_int(CODE_REGISTER, (pth[i].code))
      registers__set_int(TYPE_REGISTER, (pth[i].typ))
      --set termination for tp
      SELECT (pth[i].code) OF
        CASE(PTH_MOVETO,PTH_CLOSE): registers__set_int(TERM_REGISTER, TERM_FINE) ;
        ELSE: registers__set_int(TERM_REGISTER, TERM_CONT) ;
      ENDSELECT

      --set pose
      nde = tpath2pos(pth[i])
      set_posereg(nde, POSE_REG)
      --move to pose
      CALL_PROG(LINEAR_MOVE_PROG, 0)
    ENDFOR
  END moveLine

ROUTINE moveArc
  VAR
    i, status : INTEGER
    nde, nde_tool : PATH_DATA_TYPE
  BEGIN
    --make tool offset pose to be multiplied in
    --as circular_move does not allow the use of
    --the tool_offset modifier
    nde_tool = poseInv(tool_offset)

    --linear move to start of path
    --LS program should handle PTH_MOVETO case
      --set code and type for tp
    IF PATH_LEN(pth) > 0 THEN
      registers__set_int(CODE_REGISTER, PTH_MOVETO)
      registers__set_int(TYPE_REGISTER, (pth[1].typ))
      registers__set_int(TERM_REGISTER, TERM_FINE)
        --set pose
      nde = tpath2pos(pth[1])
      nde = poseMul(nde, nde_tool)
      set_posereg(nde, ARC_REG1)
        --move to pose
      CALL_PROG(ARC_MOVE_PROG, 0)
    ENDIF

    --for circular motion need to define the next two points for motion
    --LS program should handle PTH_CLOSE case
    i = 2
    WHILE i < PATH_LEN(pth) DO
      --set code and type for tp
      SELECT pth[i+1].code OF
        CASE(PTH_MOVETO,PTH_CLOSE):
          registers__set_int(CODE_REGISTER, PTH_CLOSE)
        ELSE:
          registers__set_int(CODE_REGISTER, (pth[i+1].code))
      ENDSELECT
      registers__set_int(TYPE_REGISTER, (pth[i+1].typ))
      registers__set_int(TERM_REGISTER, TERM_CONT) ;

      --Do not use cicular_move if less than 3 points
      IF PATH_LEN(pth) < 3 THEN
        set_posereg(tool_offset, TOOL_OFFSET_REG)
        nde = tpath2pos(pth[i])
        set_posereg(nde, POSE_REG)
      --move to pose
        CALL_PROG(LINEAR_MOVE_PROG, 0)
      ELSE
        --set midpoint
        nde = tpath2pos(pth[i])
        nde = poseMul(nde, nde_tool)
        set_posereg(nde, ARC_REG1)
        --set endpoint
        nde = tpath2pos(pth[i+1])
        nde = poseMul(nde, nde_tool)
        set_posereg(nde, ARC_REG2)

        CALL_PROG(ARC_MOVE_PROG, 0)
      ENDIF

      i = i + 2
    ENDWHILE
  END moveArc

ROUTINE movePoly
  VAR
    i : INTEGER
    nde : PATH_DATA_TYPE
  BEGIN
    --set tool orientation
    set_posereg(tool_offset, TOOL_OFFSET_REG)

    REPEAT
      next_toolpath(tool_speed, tool_step, link_speed, link_step, retract_hght)

      FOR i=1 TO PATH_LEN(pth) DO
        --set code and type for tp
        registers__set_int(CODE_REGISTER, (pth[i].code))
        registers__set_int(TYPE_REGISTER, (pth[i].typ))
        --set termination for tp
        SELECT pth[i].code OF
          CASE(PTH_MOVETO,PTH_CLOSE): registers__set_int(TERM_REGISTER, TERM_FINE) ;
          ELSE: registers__set_int(TERM_REGISTER, TERM_CONT) ;
        ENDSELECT

        --set pose
        nde = tpath2pos(pth[i])
        set_posereg(nde, POSE_REG)
        --move to pose
        CALL_PROG(LINEAR_MOVE_PROG, 0)
      ENDFOR
    UNTIL(`PATH_PLAN_NAME`__is_path_end)

  END movePoly

ROUTINE movePolyFull
  VAR
    i : INTEGER
    nde : PATH_DATA_TYPE
  BEGIN
    --set tool orientation
    set_posereg(tool_offset, TOOL_OFFSET_REG)

    get_toolpath(tool_speed, tool_step, link_speed, link_step, retract_hght)

    FOR i=1 TO PATH_LEN(pth) DO
      --set code and type for tp
      registers__set_int(CODE_REGISTER, (pth[i].code))
      registers__set_int(TYPE_REGISTER, (pth[i].typ))
      --set termination for tp
      SELECT pth[i].code OF
        CASE(PTH_MOVETO,PTH_CLOSE): registers__set_int(TERM_REGISTER, TERM_FINE) ;
        ELSE: registers__set_int(TERM_REGISTER, TERM_CONT) ;
      ENDSELECT

      --set pose
      nde = tpath2pos(pth[i])
      set_posereg(nde, POSE_REG)
      --move to pose
      CALL_PROG(LINEAR_MOVE_PROG, 0)
    ENDFOR

  END movePolyFull

ROUTINE movePolyArc
  VAR
    i, status : INTEGER
    nde, nde_tool : PATH_DATA_TYPE
  BEGIN
    --make tool offset pose to be multiplied in
    --as circular_move does not allow the use of
    --the tool_offset modifier
    nde_tool = poseInv(tool_offset)

    REPEAT
      next_toolpath(tool_speed, tool_step, link_speed, link_step, retract_hght)

      --linear move to start of path
        --set code and type for tp
      IF PATH_LEN(pth) > 0 THEN
        registers__set_int(CODE_REGISTER, PTH_MOVETO)
        registers__set_int(TYPE_REGISTER, (pth[1].typ))
        registers__set_int(TERM_REGISTER, TERM_FINE)
          --set pose
        nde = tpath2pos(pth[1])
        nde = poseMul(nde, nde_tool)
        set_posereg(nde, ARC_REG1)
          --move to pose
        CALL_PROG(ARC_MOVE_PROG, 0)
      ENDIF

      --for circular motion need to define the next two points for motion
      --LS program should handle PTH_CLOSE case
      i = 2
      WHILE i < PATH_LEN(pth) DO
        --Do not use cicular_move if less than 3 points
        IF PATH_LEN(pth) < 3 THEN
          set_posereg(tool_offset, TOOL_OFFSET_REG)

          registers__set_int(CODE_REGISTER, PTH_CLOSE)
          registers__set_int(TYPE_REGISTER, (pth[i].typ))
          registers__set_int(TERM_REGISTER, TERM_FINE)

          nde = tpath2pos(pth[i])
          set_posereg(nde, POSE_REG)
          --move to pose
          CALL_PROG(LINEAR_MOVE_PROG, 0)
        ELSE
          --set code and type for tp
          SELECT pth[i+1].code OF
            CASE(PTH_MOVETO,PTH_CLOSE):
              registers__set_int(CODE_REGISTER, PTH_CLOSE)
            ELSE:
              registers__set_int(CODE_REGISTER, (pth[i+1].code))
          ENDSELECT
          registers__set_int(TYPE_REGISTER, (pth[i+1].typ))
          registers__set_int(TERM_REGISTER, TERM_CONT)

          --set midpoint
          nde = tpath2pos(pth[i])
          nde = poseMul(nde, nde_tool)
          set_posereg(nde, ARC_REG1)
          --set endpoint
          nde = tpath2pos(pth[i+1])
          nde = poseMul(nde, nde_tool)
          set_posereg(nde, ARC_REG2)

          CALL_PROG(ARC_MOVE_PROG, 0)
        ENDIF

        i = i + 2
      ENDWHILE

    UNTIL(`PATH_PLAN_NAME`__is_path_end)

  END movePolyArc

ROUTINE movePolyArcFull
  VAR
    i : INTEGER
    startCode,endCode : INTEGER
    nde, nde_tool : PATH_DATA_TYPE
  BEGIN
    --make tool offset pose to be multiplied in
    --as circular_move does not allow the use of
    --the tool_offset modifier
    nde_tool = poseInv(tool_offset)

    --set tool orientation
    set_posereg(tool_offset, TOOL_OFFSET_REG)

    get_toolpath(tool_speed, tool_step, link_speed, link_step, retract_hght)

    startCode = pth[1].code
    endCode = paths__opposite_code(startCode)

    i = 1
    WHILE i < PATH_LEN(pth) DO
      IF pth[i].code = startCode THEN
        registers__set_int(CODE_REGISTER, PTH_MOVETO)
        registers__set_int(TYPE_REGISTER, (pth[i].typ))
        registers__set_int(TERM_REGISTER, TERM_FINE)
          --set pose
        nde = tpath2pos(pth[i])
        nde = poseMul(nde, nde_tool)
        set_posereg(nde, ARC_REG1)
          --move to pose
        CALL_PROG(ARC_MOVE_PROG, 0)

        endCode = paths__opposite_code(startCode)

        i = i + 1
      ELSE IF pth[i].code = endCode THEN
        registers__set_int(CODE_REGISTER, PTH_CLOSE)
        registers__set_int(TYPE_REGISTER, (pth[i].typ))
        registers__set_int(TERM_REGISTER, TERM_FINE)
        set_posereg(tool_offset, TOOL_OFFSET_REG)

        --set pose
        nde = tpath2pos(pth[i])
        set_posereg(nde, POSE_REG)
        --move to pose
        CALL_PROG(LINEAR_MOVE_PROG, 0)

        i = i + 1
      ELSE IF pth[i+1].code = endCode THEN
        registers__set_int(CODE_REGISTER, PTH_CLOSE)
        registers__set_int(TYPE_REGISTER, (pth[i+1].typ))
        registers__set_int(TERM_REGISTER, TERM_CONT)

        --set midpoint
        nde = tpath2pos(pth[i])
        nde = poseMul(nde, nde_tool)
        set_posereg(nde, ARC_REG1)
        --set endpoint
        nde = tpath2pos(pth[i+1])
        nde = poseMul(nde, nde_tool)
        set_posereg(nde, ARC_REG2)
        --move to pose
        CALL_PROG(ARC_MOVE_PROG, 0)
        
        IF (i + 2) < PATH_LEN(pth) THEN
          startCode = pth[i + 2].code
        ENDIF
        i = i + 2
      ELSE
        registers__set_int(CODE_REGISTER, (pth[i+1].code))
        registers__set_int(TYPE_REGISTER, (pth[i+1].typ))
        registers__set_int(TERM_REGISTER, TERM_CONT)

        --set midpoint
        nde = tpath2pos(pth[i])
        nde = poseMul(nde, nde_tool)
        set_posereg(nde, ARC_REG1)
        --set endpoint
        nde = tpath2pos(pth[i+1])
        set_posereg(nde, ARC_REG2)
        --move to pose
        CALL_PROG(ARC_MOVE_PROG, 0)

        i = i + 2
      ENDIF
      ENDIF
      ENDIF
    ENDWHILE

  END movePolyArcFull

BEGIN
END class_name
