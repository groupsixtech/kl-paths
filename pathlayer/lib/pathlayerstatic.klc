PROGRAM class_name
%NOBUSYLAMP
%COMMENT = 'pthlayerstat'
%NOLOCKGROUP

%include namespace.m

%define BASE_CLASSNAME class_name

%include pathlayer.deps.klt

%include errors.klt
%include systemvars.klt
%include systemlib.types.klt
%include systemlib.datatypes.klt
%include pose.const.klt
%include pathlib.klt
%include lam.klt
%include toolpath.structs.klt

--define layout struct
layout_type

--
VAR
  this   : t_PATH_LAYER
  params : t_PATH_PARAM
  layoutCDS : t_COORD_SYS
  passes : PATH nodedata = t_INTEGER
  layers : INTEGER
  program_type : INTEGER

-- include reference to pathmake "pth", and "line_endpnts".
%include pathmake.friend.members.klt
pathmake_friends(PATH_OBJECT_NAME)

-- include reference to pathlayout "buffer".
%include pathlayout.friends.klt
pathlayout_friends(LAYOUT_OBJECT_NAME,LAYOUT_STRUCT)

%include errors.klh
%from systemlib.klh %import VEC, VEC2D
%from math.klh %import norm
%from pose.klh %import cartesian_to_cylindrical
%from pathlib.klh %import clear_toolpath, new_coord_sys


--define layout object
define_pathlayout(LAYOUT_OBJECT_NAME,LAYOUT_CONFIG_FILENAME)

--define path object
path_make_define(PATH_OBJECT_NAME,CONFIG_FILENAME)

--motion object
path_motion_define(MOTION_OBJECT_NAME,CONFIG_FILENAME)

--lam object
lam_define(LAM_NAME,LAM_CNFG)

%defeval class_name BASE_CLASSNAME

%include pathlayerstatic.klh
%include pathlayerstatic.private.klh

--private

ROUTINE clear_passes
  VAR
    i : INTEGER
    status : INTEGER
  BEGIN
    i = PATH_LEN(passes)
    WHILE PATH_LEN(passes) > 0 DO
		  DELETE_NODE(passes,i,status)
      i = i - 1
	  ENDWHILE
  END clear_passes

ROUTINE move_to_start_pass
  VAR
    i : INTEGER
    passes : INTEGER
  BEGIN
    -- get the start pass index
    IF (this.start_pass > 0) THEN
      passes = 0

      FOR i=1 TO PATH_LEN(buffer) DO
        IF (buffer[i].code = PTH_CLOSE) THEN
          passes = passes + 1
        ENDIF

        IF (passes = this.start_pass) THEN
          this.last_idx = i
          RETURN
        ENDIF
      ENDFOR

      karelError(PATH_INDEX_OUT_OF_RANGE,'Path is out of range of the layer buffer.', ER_ABORT)

    ENDIF
  END move_to_start_pass

  -- user macro
impl_buffer_conversion

--public
ROUTINE new
  VAR
    prm : t_PATH_PARAM
  BEGIN
    --initialize lam
    `LAM_NAME`__init(lsrprm_, powprm_)

    --set params
    --make copy
    params.frm = (make_prm_.frm)
    params.idod = (make_prm_.idod)
    params.origin = (make_prm_.origin)
    params.coord_system = paths__new_coord_sys((make_prm_.coord_system.system), (make_prm_.coord_system.z_axis))
    params.usePathPlan = (make_prm_.usePathPlan)

    --with static input assume it is always in cartesean
    --save PTH_CYLINDER, or PTH_POLAR in layer object to differentiate
    layoutCDS = paths__new_coord_sys(PTH_CARTESAN, (make_prm_.coord_system.z_axis))

    --initialize pathmake
    `PATH_OBJECT_NAME`__init((params.frm), layoutCDS, (params.origin), (params.idod), (params.usePathPlan))
    --set linking coordinate system. Set as PTH_CYLINDER, or PTH_POLAR to transform linking
    `PATH_OBJECT_NAME`__set_linking_coordinate_system((make_prm_.coord_system.system), (make_prm_.coord_system.z_axis))

    --initialize pathmotion
    `MOTION_OBJECT_NAME`__init2(mtnprm_, toolprm_)
     --needed for using LAM
    program_type = (mtnprm_.program_type)

    clear_passes
    layers = 0
    this = layer_prm_
  END new

ROUTINE delete
  VAR
    uninit_lay : t_PATH_LAYER
    uninit_prm : t_PATH_PARAM
    uninit_cds : t_COORD_SYS
    uninit_tool : t_TOOL_VARS
  BEGIN
    --pathmake delete
    `PATH_OBJECT_NAME`__delete

    --layout delete
    `LAYOUT_OBJECT_NAME`__delete

    --motion delete
    `MOTION_OBJECT_NAME`__delete

    --lam delete
    `LAM_NAME`__delete

    clear_passes

    this = uninit_lay
    params = uninit_prm
    layoutCDS = uninit_cds
  END delete

-- From layout

ROUTINE import_layout
  BEGIN
    `LAYOUT_OBJECT_NAME`__new(filename, (layoutCDS.system), (layoutCDS.z_axis) )
    --calculate passes per layer
    `LAYOUT_OBJECT_NAME`__openfile
    `LAYOUT_OBJECT_NAME`__countInstances(passes)
    layers = PATH_LEN(passes)
    `LAYOUT_OBJECT_NAME`__closefile
  END import_layout

ROUTINE open_layout
  VAR
    i : INTEGER
    eof : BOOLEAN
  BEGIN
    `LAYOUT_OBJECT_NAME`__openfile

    IF (this.start_layer > 0) THEN
      --queue up for starting layer
      eof = FALSE
      FOR i=1 TO this.start_layer DO
        IF (NOT eof) THEN
          eof = `LAYOUT_OBJECT_NAME`__loadBuffer
        ENDIF
      ENDFOR
    ENDIF
  END open_layout

ROUTINE close_layout
  BEGIN
    `LAYOUT_OBJECT_NAME`__closefile
  END close_layout

ROUTINE next_layer
  --returns true if at the end of the file
  VAR
    eof : BOOLEAN
  BEGIN
    -- load next layer into `buffer` attribute
    eof = `LAYOUT_OBJECT_NAME`__loadBuffer

    --get current layer
      -- remap to 0 index (i.e. 0 = Layer 1, 1 = Layer 2)
        -- get_index_base is either 0 or 1, subtract off so layer 1 = 0
      this.curr_layer = buffer[1].layer - `LAYOUT_OBJECT_NAME`__get_index_base

      --reset passes
      IF (this.curr_layer <= this.start_layer) THEN
        this.curr_pass = this.start_pass
        --index buffer pointer to start pass
        move_to_start_pass
      ELSE
        this.curr_pass = 0
        this.last_idx = 0
      ENDIF


%ifdef DEBUG_BUILD
      usrdis__print(INFO, 'current layer: ' + i_to_s((this.curr_layer)))
      usrdis__print(INFO, 'laystrtPnt: ' + p_to_s(pth_endpnts[1].v))
      usrdis__print(INFO, 'layendPnt: ' + p_to_s(pth_endpnts[2].v))
%endif

    RETURN(NOT eof)
  END next_layer

ROUTINE next_pass
  --returns true if at the end of the layer buffer
  VAR
    layer_len : INTEGER
%ifdef DEBUG_BUILD
    i : INTEGER
%endif
  BEGIN

%ifdef DEBUG_BUILD
    usrdis__print(INFO, 'loading pass ' + i_to_s((this.curr_pass)) + ' into PATH_OBJECT_NAME->pth')
    i = 0
%endif

    -- if buffer is empty, exit
    IF PATH_LEN(buffer) = 0 THEN
      karelError(PATH_INDEX_OUT_OF_RANGE,'Nothing is in the path buffer.', ER_WARN)
      RETURN(FALSE)
    ENDIF

    --clear previous path_make pth
    paths__clear_toolpath(pth)
    paths__clear_toolpath(line_endpnts)

    --start buffer index at the next line/pass
    REPEAT
      this.last_idx = this.last_idx + 1
      --make t_TOOLPATH node (convert from buffer to t_TOOLPATH)
      layout_to_toolpath((this.last_idx), layoutCDS, pth)

%ifdef DEBUG_BUILD
      usrdis__print(DEBUG, 'load ' + i_to_s(this.last_idx) + '/' + i_to_s(PATH_LEN(buffer)) + ' nodes')
      i = i + 1
%endif

    UNTIL(pth[PATH_LEN(pth)].code = PTH_CLOSE) --repeat until at the end of a toolpath segment

    --pathmake->`pth_end` should always be true as passes
    --is set externally by `next_pass`, and the `pth` member
    --should only be a single path. Pass through motion->move.
    `PATH_OBJECT_NAME`__set_path_end(TRUE)

    this.curr_pass = this.curr_pass + 1

    IF this.last_idx >= PATH_LEN(buffer) THEN
      --at the end of the layer buffer
%ifdef DEBUG_BUILD
      usrdis__print(INFO, '^^reached end of pass buffer^^')
%endif
      
      RETURN(FALSE)
    ENDIF

%ifdef DEBUG_BUILD
    usrdis__print(INFO, 'loaded ' + i_to_s(i) + ' nodes into pth')
%endif

    RETURN(TRUE)

  END next_pass

ROUTINE set_start_layer
  BEGIN
    this.start_layer = startlay
  END set_start_layer

ROUTINE set_start_pass
  BEGIN
    this.start_pass = startpass
  END set_start_pass

-- user macro
impl_inter_logic

ROUTINE run
  VAR
    bLayer : BOOLEAN
    bPass : BOOLEAN
  BEGIN
    --lock groups
    `MOTION_OBJECT_NAME`__aquire_groups

    --start extruder and enable laser
    lam_start

    --open layout file & load starting layer
    open_layout

    --loop layers
    REPEAT
      --set next layer
      bLayer = next_layer
%ifdef DEBUG_BUILD
      usrdis__print(DEBUG, 'next layer = ' + b_to_s(bLayer) )
%endif

      --interlayer start logic
      --(i.e. pause, cool, rotate part)
      interStartLayer

      --approach point
      `MOTION_OBJECT_NAME`__moveApproach

      --loop passes
      REPEAT
        --set next pass
        bPass = next_pass
%ifdef DEBUG_BUILD
        usrdis__print(DEBUG, 'next pass = ' + b_to_s(bPass) )
%endif

        --move through pass/layer
          --use linear moves for tool path
        `MOTION_OBJECT_NAME`__move(FALSE)
        interPass

        --run linking pass
        IF bPass THEN
          `MOTION_OBJECT_NAME`__move(FALSE)
        ENDIF
      UNTIL (NOT bPass) -- check if there are more passes to read

      --interlayer stop logic
      interStopLayer

      --retract point
      `MOTION_OBJECT_NAME`__moveRetract
    UNTIL (NOT bLayer) -- check if there are more layers to read

    --close layout file
    close_layout

    --stop extruder and disable laser
    lam_stop

    --unlock groups
    `MOTION_OBJECT_NAME`__release_groups
  END run

ROUTINE lam_start
  BEGIN
    IF program_type = MOVE_WORKING THEN
      `LAM_NAME`__set_registers
      `LAM_NAME`__start
    ENDIF
  END lam_start

ROUTINE lam_stop
  BEGIN
    IF program_type = MOVE_WORKING THEN
      `LAM_NAME`__stop
    ENDIF
  END lam_stop

BEGIN
END class_name