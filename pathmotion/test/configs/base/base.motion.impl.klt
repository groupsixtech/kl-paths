--include default interface
%include motion.interface.klt

-- ***********
-- Define type
-- ***********

-- for a simple type
%defeval MOTION_DATA_TYPE XYZWPR
%defeval MOTION_DATA_FILE rbtgp1

-- ***********
-- initialization  
-- ***********

%defeval DEFAULT_POSE new_pose(0,0,0,0,0,0, pose__set_config(DEFAULT_CONFIG))

-- ***********
-- Define interface header
-- ***********

%mode push
%mode string QQQ "`" "`" "\\"

%define impl_motion_head(parent) `declare_member(parent,new_pose,parent,npose)
ROUTINE new_pose(x,y,z,w,p,r : REAL; cnfg : CONFIG) : MOTION_DATA_TYPE FROM parent
declare_member(parent,new_cart,parent,ncart)
ROUTINE new_cart(x,y,z,w,p,r : REAL; cnfg : CONFIG) : MOTION_DATA_TYPE FROM parent
declare_member(parent,make_tool_offset,parent,mktof)
ROUTINE make_tool_offset(ofst : XYZWPR) : MOTION_DATA_TYPE  FROM parent
declare_member(parent,make_user_offset,parent,mkuof)
ROUTINE make_user_offset(deg_offset : REAL) : MOTION_DATA_TYPE FROM parent
declare_member(parent,define_tool_offset,parent,dftof)
ROUTINE define_tool_offset(toolprm : t_TOOL_VARS) FROM parent
declare_member(parent,set_lpos,parent,stlps)
ROUTINE set_lpos : MOTION_DATA_TYPE FROM parent
declare_member(parent,tpath2pos,parent,tppse)
ROUTINE tpath2pos(nde : t_TOOLPATH) : MOTION_DATA_TYPE FROM parent
declare_member(parent,set_posereg,parent,stpr)
ROUTINE set_posereg(nde : MOTION_DATA_TYPE; reg_no : INTEGER) FROM parent
declare_member(parent,get_cart,parent,gtcrt)
ROUTINE get_cart(nde : MOTION_DATA_TYPE) : XYZWPR FROM parent
declare_member(parent,get_component,parent,gtcmp)
ROUTINE get_component(nde : MOTION_DATA_TYPE; grp_no : INTEGER; comp_no : INTEGER) : REAL FROM parent
declare_member(parent,poseMul,parent,psmul)
ROUTINE poseMul(nde1 : MOTION_DATA_TYPE; nde2 : MOTION_DATA_TYPE) : MOTION_DATA_TYPE FROM parent
declare_member(parent,poseInv,parent,psinv)
ROUTINE poseInv(nde1 : MOTION_DATA_TYPE) : MOTION_DATA_TYPE FROM parent
declare_member(parent,approachPath,parent,appth)
ROUTINE approachPath(speed : REAL; stepSize : REAL; coordSys : INTEGER; idod : INTEGER; origin : XYZWPR; offset : XYZWPR) FROM parent
declare_member(parent,retractPath,parent,rtpth)
ROUTINE retractPath(speed : REAL; stepSize : REAL; coordSys : INTEGER; idod : INTEGER; origin : XYZWPR; offset : XYZWPR) FROM parent
`

%mode pop

-- ***********
-- Define interface
-- ***********

%mode push
%mode string QQQ "`" "`" "\\"

%define impl_motion_members(parent) `declare_member(parent,new_pose,parent,npose)
ROUTINE new_pose(x,y,z,w,p,r : REAL; cnfg : CONFIG) : MOTION_DATA_TYPE
  BEGIN
    RETURN( POS(x,y,z,w,p,r, cnfg) )
  END new_pose

declare_member(parent,new_cart,parent,ncart)
ROUTINE new_cart(x,y,z,w,p,r : REAL; cnfg : CONFIG) : MOTION_DATA_TYPE
  BEGIN
    RETURN( POS(x,y,z,w,p,r, cnfg) )
  END new_cart

declare_member(parent,make_tool_offset,parent,mktof)
ROUTINE make_tool_offset(ofst : XYZWPR) : MOTION_DATA_TYPE
  BEGIN
    RETURN( ofst )
  END make_tool_offset

declare_member(parent,make_user_offset,parent,mkuof)
ROUTINE make_user_offset(deg_offset : REAL) : MOTION_DATA_TYPE
  BEGIN
    RETURN(new_pose(0,0,0,0,0,0, pose__set_config(DEFAULT_CONFIG)))
  END make_user_offset

declare_member(parent,define_tool_offset,parent,dftof)
ROUTINE define_tool_offset(toolprm : t_TOOL_VARS)
  BEGIN
    --set tool offset
    tool_offset = new_pose(0,0,0,(toolprm.orient.x + toolprm.pitch), toolprm.orient.y, toolprm.orient.z, pose__set_config(DEFAULT_CONFIG))
    frame_offset = make_user_offset(0)

  END define_tool_offset

declare_member(parent,set_lpos,parent,stlps)
ROUTINE set_lpos : MOTION_DATA_TYPE
  BEGIN
    RETURN( pose__get_lpos(RBT_GRP) )
  END set_lpos

declare_member(parent,tpath2pos,parent,tppse)
ROUTINE tpath2pos(nde : t_TOOLPATH) : MOTION_DATA_TYPE
  BEGIN
    RETURN(nde.v)
  END tpath2pos

declare_member(parent,set_posereg,parent,stpr)
ROUTINE set_posereg(nde : MOTION_DATA_TYPE; reg_no : INTEGER)
  BEGIN
    pose__set_posreg_xyz(nde, reg_no, RBT_GRP)
  END set_posereg

declare_member(parent,get_cart,parent,gtcrt)
ROUTINE get_cart(nde : MOTION_DATA_TYPE) : XYZWPR
  BEGIN
    RETURN(nde)
  END get_cart

declare_member(parent,get_component,parent,gtcmp)
ROUTINE get_component(nde : MOTION_DATA_TYPE; grp_no : INTEGER; comp_no : INTEGER) : REAL
  BEGIN
    SELECT comp_no OF
      CASE(1):
        RETURN(nde.x)
      CASE(2):
        RETURN(nde.y)
      CASE(3):
        RETURN(nde.z)
      CASE(4):
        RETURN(nde.w)
      CASE(5):
        RETURN(nde.p)
      CASE(6):
        RETURN(nde.r)
      ELSE:
        karelError(INVALID_TYPE_CODE, 'Component number is not valid', ER_ABORT)
    ENDSELECT

    RETURN(0)
  END get_component

declare_member(parent,poseMul,parent,psmul)
ROUTINE poseMul(nde1 : MOTION_DATA_TYPE; nde2 : MOTION_DATA_TYPE) : MOTION_DATA_TYPE
  BEGIN
    RETURN(nde1:nde2)
  END poseMul

declare_member(parent,poseInv,parent,psinv)
ROUTINE poseInv(nde1 : MOTION_DATA_TYPE) : MOTION_DATA_TYPE
  BEGIN
    RETURN(INV((nde1)))
  END poseInv
declare_member(parent,approachPath,parent,appth)
ROUTINE approachPath(speed : REAL; stepSize : REAL; coordSys : INTEGER; idod : INTEGER; origin : XYZWPR; offset : XYZWPR)
  VAR
%define APPROACH_DEGREE_DIFF 5
    lpos : XYZWPR
    spos, spos2 : VECTOR
    vpos1, vpos2 : VECTOR
  BEGIN
    spos = VEC(origin.x,origin.y+offset.y,origin.z-idod*offset.z)
    spos2 = VEC(origin.x,origin.y,origin.z-idod*offset.z)

%ifdef DEBUG_BUILD
    usrdis__print(DEBUG, '* Approach *')
    usrdis__print(DEBUG, 'spos: ' + vec_to_s(spos, ','))
    usrdis__print(DEBUG, 'spos2: ' + vec_to_s(spos2, ','))
%endif

    --move to offset -> to zero poisition
    `PATH_OBJECT_NAME`__makeline(spos, spos2, (ZEROPOS(1)), PTH_LINKING, PTH_LINETO, stepSize, speed, 1, VEC(1,0,0))
    moveLine

    --origin point
    vpos1 = INV((origin)):spos2

    --get start position of path from drawing
    lpos = `PATH_OBJECT_NAME`__get_start_node
    vpos2 = VEC(lpos.x, lpos.y, lpos.z)

    --apply retract offset
    vpos2.z = vpos2.z-idod*offset.z

%ifdef DEBUG_BUILD
    usrdis__print(DEBUG, 'vpos1: ' + vec_to_s(vpos1, ','))
    usrdis__print(DEBUG, 'vpos2: ' + vec_to_s(vpos2, ','))
%endif

    IF (coordSys=PTH_CYLINDER) THEN
      --move between origin and start degree
      IF (ABS(vpos2.x - vpos1.x) > APPROACH_DEGREE_DIFF) THEN
        -- ..note:: set travel direction in step size
        `PATH_OBJECT_NAME`__makeline(vpos1, vpos2, origin, PTH_LINKING, PTH_LINETO, stepSize, speed, 1, VEC(1,0,0))
        moveArc
      ENDIF
    ENDIF

    IF (coordSys=PTH_CARTESAN) THEN
      `PATH_OBJECT_NAME`__makeline(vpos1, vpos2, origin, PTH_LINKING, PTH_LINETO, stepSize, speed, 1, VEC(1,0,0))
      moveLine
    ENDIF

  END approachPath
declare_member(parent,retractPath,parent,rtpth)
ROUTINE retractPath(speed : REAL; stepSize : REAL; coordSys : INTEGER; idod : INTEGER; origin : XYZWPR; offset : XYZWPR)
  VAR
%define APPROACH_DEGREE_DIFF 5
    lpos : XYZWPR
    lposOffset : REAL
    vpos1, vpos2, vpos3 : VECTOR
    spos : VECTOR
    fpos : VECTOR
  BEGIN

%ifdef DEBUG_BUILD
    usrdis__print(DEBUG, '* Retract *')
    -- WRITE TPDISPLAY('* Retract *', CR)
%endif

    lpos = pose__get_lpos(1)

    --if cylindrical. Convert.
    IF (coordSys=PTH_CYLINDER) THEN
      lpos = pose__cartesian_to_cylindrical((ZEROPOS(1)), lpos, VERT_AXES, 0, FALSE)
%ifdef DEBUG_BUILD
      usrdis__print(DEBUG, 'lpos: ' + vec_to_s(VEC(lpos.x, lpos.y, lpos.z), ','))
%endif
      --change degrees to mm
      lpos.x = ((360-lpos.x-0)*origin.z*M_PI/180)
    ENDIF

    -- set default orientation
    lpos = pose__replace_orient(lpos, paths__set_orientation(coordSys, idod))

    --convert into drawing frame
    lpos = INV((origin)):lpos
    --lpos.x = -1*idod*lpos.x
    vpos1 = VEC(lpos.x, lpos.y, lpos.z)

    -- retract point
    vpos2 = vpos1
    vpos2.z = vpos1.z-idod*offset.z

%ifdef DEBUG_BUILD
    usrdis__print(DEBUG, 'vpos1: ' + vec_to_s(vpos1, ','))
    usrdis__print(DEBUG, 'vpos2: ' + vec_to_s(vpos1, ','))
%endif

    --move up from lpos to the retract height
    `PATH_OBJECT_NAME`__makeline(vpos1, vpos2, origin, PTH_LINKING, PTH_LINETO, stepSize, speed, 1, VEC(1,0,0))
    moveLine

    -- get origin point
    spos = VEC(0,0,0)
    -- ..warning:: modifying z manually
    spos.z = vpos2.z

    --unravel if cylindrical above the retract distance (x,y,z) -> (theta,z,r)
    -- move back to start point in x
    IF (coordSys=PTH_CYLINDER) THEN
      --if same point. add 360 deg to lpos
      vpos3 = vpos2
      IF (ABS(spos.x - vpos3.x) < APPROACH_DEGREE_DIFF) THEN
        vpos3.x = vpos3.x - 360*origin.z*M_PI/180
      ENDIF

%ifdef DEBUG_BUILD
      usrdis__print(DEBUG, 'vpos3: ' + vec_to_s(vpos3, ','))
      usrdis__print(DEBUG, 'spos: ' + vec_to_s(spos, ','))
%endif

      -- ..note:: set travel direction in step size.
      `PATH_OBJECT_NAME`__makeline(vpos3, spos, origin, PTH_LINKING, PTH_LINETO, stepSize, speed, -1*idod, VEC(1,0,0))
      moveArc
    ENDIF

    spos = origin:spos
    fpos = VEC(origin.x,origin.y+offset.y,spos.z)

%ifdef DEBUG_BUILD
    usrdis__print(DEBUG, 'spos2: ' + vec_to_s(spos, ','))
    usrdis__print(DEBUG, 'fpos: ' + vec_to_s(fpos, ','))
%endif

    --move from the origin to the retract distance to the offset
    `PATH_OBJECT_NAME`__makeline(spos, fpos, (ZEROPOS(1)), PTH_LINKING, PTH_LINETO, stepSize, speed, 1, VEC(1,0,0))
    moveLine

  END retractPath
`

%mode pop